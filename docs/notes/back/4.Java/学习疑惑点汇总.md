---
title: Java 学习疑惑点汇总
createTime: 2025-07-25
permalink: /backend/java/
---

## 一、基础语法

### **1.变量和数据类型**

- 变量：用于存储数据的内存空间，每个变量都有一个名称和一个类型。
- 数据类型：Java 中的数据类型包括基本数据类型和引用数据类型。
  - 基本数据类型：包括整数类型（int、long、byte、short）、浮点数类型（float、double）、字符类型（char）、布尔类型（boolean）等。
  - 引用数据类型：包括类（class）、接口（interface）、数组（array）等。
  - 字符串类型：用于表示文本数据，Java 中的字符串是不可变的，一旦创建就不能再修改。
- 运算符：用于执行各种数学和逻辑运算的符号，如加减乘除、比较运算符、逻辑运算符等。
- 控制语句：用于控制程序的执行流程，如条件语句（if、switch）、循环语句（for、while、do-while）、跳转语句（break、continue、return）等。
- 方法：用于封装一段特定的功能代码，方法可以在程序中重复调用，提高代码的复用性。
- 类和对象：Java 是一种面向对象的编程语言，类是用于定义对象的蓝图或模板，而对象是类的实例。类定义了对象的属性和方法，而对象则是类的具体实例。
- 异常处理：Java 中的异常处理机制用于处理程序运行时可能出现的错误或异常情况。异常处理可以帮助我们在程序中捕获和处理异常，避免程序崩溃或产生不可预期的结果。
- 集合框架：Java 中的集合框架提供了一种统一的方式来处理和操作一组对象。集合框架包括了各种不同的集合类，如列表（List）、集合（Set）、映射（Map）等。
- 泛型：Java 中的泛型是一种类型安全的机制，用于在编译时检查类型的正确性。泛型可以应用于类、接口和方法，提供了类型的参数化和类型的约束。
- 多线程：Java 中的多线程编程允许同时执行多个线程，提高程序的并发性和性能。多线程编程涉及到线程的创建、启动、停止、同步等问题。
- 网络编程：Java 中的网络编程允许程序通过网络进行通信和数据交换。网络编程涉及到 socket 编程、HTTP 编程、FTP 编程等。
- 数据库编程：Java 中的数据库编程允许程序与数据库进行交互和数据操作。数据库编程涉及到 JDBC 编程、SQL 语句的编写和执行、数据库连接的管理等。
- 设计模式：Java 中的设计模式是一种解决软件设计问题的经验总结和最佳实践。设计模式提供了一种结构化的方式来组织和管理代码，提高代码的可维护性、可扩展性和可复用性。
- 性能优化：Java 中的性能优化是指通过调整代码、算法、数据结构等方面的改进，来提高程序的执行效率和响应速度。性能优化涉及到代码的优化、数据库查询的优化、缓存策略的优化等。
- 代码规范：Java 中的代码规范是指编写规范的 Java 代码，以提高代码的可读性、可维护性和可复用性。代码规范包括了命名规范、缩进规范、注释规范等。
- 代码调试：Java 中的代码调试是指在程序运行过程中，通过调试工具和技术，来定位和解决程序中的错误或异常情况。代码调试涉及到断点调试、日志分析、性能分析等。
- 代码文档：Java 中的代码文档是指编写详细的文档，用于描述代码的功能、使用方法、参数说明等。代码文档可以使用 Javadoc 工具来生成 HTML 文档，方便其他开发者阅读和使用。

### **2.类型展示**

> int i = 10;
>
> long l = 10L;
>
> float f = 10.0F;
>
> double d = 10.0;
>
> char c = 'a';
>
> boolean b = true;
>
> String s = "hello";

### **3.自增和自减**

注意：`++`在前和在后，计算方式不同，

- `++i`：先自增，后赋值
- `i++`：先赋值，后自增
- `--i`：先自减，后赋值
- `i--`：先赋值，后自减

### **4.位运算**

与：`&`

- 同时为 1，结果为 1，否则为 0
  - 1 & 1 = 1
  - 1 & 0 = 0
  - 0 & 1 = 0
  - 0 & 0 = 0

或：`|`

- 有一个为 1，结果为 1，否则为 0
  - 1 | 1 = 1
  - 1 | 0 = 1
  - 0 | 1 = 1
  - 0 | 0 = 0

非：`~`

- 0 变 1，1 变 0
  - ~0 = 1
  - ~1 = 0

异或：`^`

- 相同为 0，不同为 1
  - 1 ^ 1 = 0
  - 1 ^ 0 = 1
  - 0 ^ 1 = 1
  - 0 ^ 0 = 0

### **5.短路运算**

- 逻辑与：`&&`
  - 两个条件都为 true，结果为 true，否则为 false
  - 短路：如果第一个条件为 false，后面的条件不再判断，直接返回 false
- 逻辑或：`||`
  - 两个条件有一个为 true，结果为 true，否则为 false
  - 短路：如果第一个条件为 true，后面的条件不再判断，直接返回 true
- 逻辑非：`!`
  - 取反，true 变 false，false 变 true

### **6.多行字符串表示**

```java
"""
第一行
第二行
第三行
"""
```

### **7.格式化输出**

使用 `System.out.printf()` 方法进行格式化输出。

- `%d`：整数
  - `%03d`：不足 3 位，前面补 0
- `%f`：浮点数
  - `%.2f`：保留 2 位小数
- `%s`：字符串
  - `%s`：直接输出字符串
  - `%10s`：输出字符串，不足 10 位，前面补空格
  - `%-10s`：输出字符串，不足 10 位，后面补空格
- `%c`：字符
- `%b`：布尔值
- `%x`：十六进制整数
- `%o`：八进制整数
- `%e`：科学计数法
- `%g`：通用浮点数格式
- `%a`：十六进制浮点数格式
- `%t`：日期和时间

### **8.数组**

1. 数组打印 `Arrays.toString()`

```java
import java.util.Arrays;
public class Main {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};
        System.out.println(Arrays.toString(arr)); // 1, 2, 3, 4, 5
    }
}
```

2. 数组排序 `Arrays.sort()`
3. 多维数组 `Arrays.deepToString()` 输出打印

## 二、面向对象编程

### 1.创建对象

`Person p = new Person();`

注: `Person ming` 是定义 `Person` 类型的变量`ming`,而`new Person()`是创建`Person`类型的实例。

### 2.方法

:::tip 基本类型参数绑定
基本类型参数的传递，是调用方值的复制。双方各自的后续修改，互不影响。
:::

- eg:

```java
// 基本类型参数绑定
public class Main {
    public static void main(String[] args) {
        Person p = new Person();
        int n = 15; // n的值为15
        p.setAge(n); // 传入n的值
        System.out.println(p.getAge()); // 15
        n = 20; // n的值改为20
        System.out.println(p.getAge()); // 15
        System.out.println(n); // 20

    }
}

class Person {
    private int age;

    public int getAge() {
        return this.age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}

```

::: tip 引用类型参数绑定
引用类型参数的传递，调用方的变量，和接收方的参数变量，指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方（因为指向同一个对象嘛）。
:::

- eg:

```java
// 引用类型参数绑定
public class Main {
    public static void main(String[] args) {
        Person p = new Person();
        String bob = "Bob";
        p.setName(bob); // 传入bob变量
        System.out.println(p.getName()); // "Bob"
        bob = "Alice"; // bob改名为Alice
        System.out.println(p.getName()); // "Alice"
    }
}

class Person {
    private String name;

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

```

### 3.构造方法[^1]

- 构造方法的名称必须和==类名==相同，且没有返回值类型，连 `void` 也不能有。
- 构造方法的作用是初始化对象，给对象(即实例)的成员变量赋值。
- 构造方法可以重载，根据参数的不同，调用不同的构造方法。
- 构造方法可以在创建对象时，直接给成员变量赋值。
- 构造方法可以调用其他构造方法，使用 `this()` 调用。
- 构造方法可以使用 `super()` 调用父类的构造方法，必须是第一行语句

[^1]: 自定义构造方法之后，编辑器 ==**_不再_**== 提供默认构造方法。

### 4.方法重载

- 方法重载的定义：在同一个类中，有多个方法名相同，但是参数列表不同的方法。
- 方法重载的作用：为了方便调用，减少记忆成本。
- 方法重载的注意事项：

  - 方法重载与方法的返回值类型无关。
  - 方法重载与方法的访问修饰符无关。
  - 方法重载与方法的参数列表有关，参数列表不同，方法重载。
  - 方法重载与方法的参数列表有关，参数列表相同，方法不重载。

==注意：方法重载的返回值类型通常都是相同的。==

### 5.继承

- super 的用法

```java
// super
public class Main {
    public static void main(String[] args) {
        Student s = new Student("Xiao Ming", 12, 89);
    }
}

class Person {
    protected String name;
    protected int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}

class Student extends Person {
    protected int score;

    public Student(String name, int age, int score) {
        this.score = score;
    }
}

```

运行会报错,在构造方法中 `Student` 中,无法调用 `Person`的构造方法

**解决方案**

```java
class Student extends Person {
    protected int score;

    public Student(String name, int age, int score) {
        super(name, age);  // [!code ++] 调用父类的构造方法Person(String, int)
        this.score = score;
    }
}
```

### 6.多态

- 1.方法签名相同，并且返回值也相同，就是 `Override` (覆写)

  ```java
  class Person {
    public void run() {
        System.out.println("Person.run");
    }
  }

  ```

  - 子类覆写父类方法

  ```java
  class Student extends Person {
    @Override // [!code warning] 编译器帮助检查是否进行了正确的覆写
    public void run() {
        System.out.println("Student.run");
    }
  }

  ```

- 2.方法签名相同，但是返回值不同，就是 `Overload` (重载)

- 3.多态

```java
  // override
  public class Main {
    public static void main(String[] args) {
        Person p = new Student(); // [!code warning]
        p.run(); // 应该打印Person.run还是Student.run?
    }
  }
  class Person {
    public void run() {
        System.out.println("Person.run");
    }
}

class Student extends Person {
    @Override
    public void run() {
        System.out.println("Student.run");
    }
}
```

运行一下上面的代码就可以知道，实际上调用的方法是 Student 的 run()方法。因此可得出结论：

Java 的实例方法调用是基于==运行时的实际类型的动态调用，而非变量的声明类型==。

这个非常重要的特性在面向对象编程中称之为==多态==。它的英文拼写非常复杂：Polymorphic。

### 7.抽象类

```java
abstract class Person {
    public abstract void run();
}
```

- 概念：用 `abstract` 关键字定义的类，就是抽象类。
- 作用：定义一个类，这个类的目的是为了被继承，而不是为了实例化。
  ==父类仅定义方法签名，子类去覆写实现=={.warning}

- 注意事项：

  - 抽象类不能实例化。
  - 抽象类可以定义普通方法、静态方法、实例方法、构造方法、初始化块。
  - 抽象类可以定义抽象方法，抽象方法没有方法体，只有方法名和参数列表。
  - 抽象类可以定义普通属性，普通属性可以有默认值，也可以没有默认值。

==引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。=={.important}

### 8.接口

- 在 Java 中，使用 `interface` 可以声明一个接口

```java
interface Person {
    void run();
    String getName();
}

```

所谓 `interface`，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是 `public abstract` 的，所以这两个修饰符不需要写出来（写不写效果都一样）

- 抽象类和接口的对比如下：
  | | abstract class | interface|
  | :------------- |:-------------:| -----|
  | 继承 | 只能 extends 一个 class | 可以 implements 多个 interface |
  | 字段 | 可以定义实例字段 | 不能定义实例字段 |
  | 抽象方法 | 可以定义抽象方法 | 可以定义抽象方法 |
  | 非抽象方法 | 可以定义非抽象方法 | 可以定义 default 方法 |
